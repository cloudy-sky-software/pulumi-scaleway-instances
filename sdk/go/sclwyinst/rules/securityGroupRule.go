// Code generated by pulumigen DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package rules

import (
	"context"
	"reflect"

	"errors"
	"github.com/cloudy-sky-software/pulumi-scaleway-instances/sdk/go/sclwyinst/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type SecurityGroupRule struct {
	pulumi.CustomResourceState

	Action SecurityGroupRuleActionOutput `pulumi:"action"`
	// The beginning of the range of ports to apply this rule to (inclusive)
	DestPortFrom pulumi.Float64PtrOutput `pulumi:"destPortFrom"`
	// The end of the range of ports to apply this rule to (inclusive)
	DestPortTo pulumi.Float64PtrOutput          `pulumi:"destPortTo"`
	Direction  SecurityGroupRuleDirectionOutput `pulumi:"direction"`
	// Indicates if this rule is editable (will be ignored)
	Editable pulumi.BoolPtrOutput `pulumi:"editable"`
	// (IP network)
	IpRange pulumi.StringOutput `pulumi:"ipRange"`
	// The position of this rule in the security group rules list
	Position pulumi.Float64PtrOutput                      `pulumi:"position"`
	Protocol SecurityGroupRuleProtocolOutput              `pulumi:"protocol"`
	Rule     ScalewayInstanceV1SecurityGroupRulePtrOutput `pulumi:"rule"`
}

// NewSecurityGroupRule registers a new resource with the given unique name, arguments, and options.
func NewSecurityGroupRule(ctx *pulumi.Context,
	name string, args *SecurityGroupRuleArgs, opts ...pulumi.ResourceOption) (*SecurityGroupRule, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.IpRange == nil {
		return nil, errors.New("invalid value for required argument 'IpRange'")
	}
	if args.Action == nil {
		args.Action = SecurityGroupRuleAction("accept")
	}
	if args.Direction == nil {
		args.Direction = SecurityGroupRuleDirection("inbound")
	}
	if args.Protocol == nil {
		args.Protocol = SecurityGroupRuleProtocol("TCP")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource SecurityGroupRule
	err := ctx.RegisterResource("scaleway-instances:rules:SecurityGroupRule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSecurityGroupRule gets an existing SecurityGroupRule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSecurityGroupRule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SecurityGroupRuleState, opts ...pulumi.ResourceOption) (*SecurityGroupRule, error) {
	var resource SecurityGroupRule
	err := ctx.ReadResource("scaleway-instances:rules:SecurityGroupRule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering SecurityGroupRule resources.
type securityGroupRuleState struct {
}

type SecurityGroupRuleState struct {
}

func (SecurityGroupRuleState) ElementType() reflect.Type {
	return reflect.TypeOf((*securityGroupRuleState)(nil)).Elem()
}

type securityGroupRuleArgs struct {
	Action SecurityGroupRuleAction `pulumi:"action"`
	// The beginning of the range of ports to apply this rule to (inclusive)
	DestPortFrom *float64 `pulumi:"destPortFrom"`
	// The end of the range of ports to apply this rule to (inclusive)
	DestPortTo *float64                   `pulumi:"destPortTo"`
	Direction  SecurityGroupRuleDirection `pulumi:"direction"`
	// Indicates if this rule is editable (will be ignored)
	Editable *bool `pulumi:"editable"`
	// (IP network)
	IpRange string `pulumi:"ipRange"`
	// The position of this rule in the security group rules list
	Position *float64                  `pulumi:"position"`
	Protocol SecurityGroupRuleProtocol `pulumi:"protocol"`
	// UUID of the security group
	SecurityGroupId *string `pulumi:"securityGroupId"`
	// The zone you want to target
	Zone *string `pulumi:"zone"`
}

// The set of arguments for constructing a SecurityGroupRule resource.
type SecurityGroupRuleArgs struct {
	Action SecurityGroupRuleActionInput
	// The beginning of the range of ports to apply this rule to (inclusive)
	DestPortFrom pulumi.Float64PtrInput
	// The end of the range of ports to apply this rule to (inclusive)
	DestPortTo pulumi.Float64PtrInput
	Direction  SecurityGroupRuleDirectionInput
	// Indicates if this rule is editable (will be ignored)
	Editable pulumi.BoolPtrInput
	// (IP network)
	IpRange pulumi.StringInput
	// The position of this rule in the security group rules list
	Position pulumi.Float64PtrInput
	Protocol SecurityGroupRuleProtocolInput
	// UUID of the security group
	SecurityGroupId pulumi.StringPtrInput
	// The zone you want to target
	Zone pulumi.StringPtrInput
}

func (SecurityGroupRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*securityGroupRuleArgs)(nil)).Elem()
}

type SecurityGroupRuleInput interface {
	pulumi.Input

	ToSecurityGroupRuleOutput() SecurityGroupRuleOutput
	ToSecurityGroupRuleOutputWithContext(ctx context.Context) SecurityGroupRuleOutput
}

func (*SecurityGroupRule) ElementType() reflect.Type {
	return reflect.TypeOf((**SecurityGroupRule)(nil)).Elem()
}

func (i *SecurityGroupRule) ToSecurityGroupRuleOutput() SecurityGroupRuleOutput {
	return i.ToSecurityGroupRuleOutputWithContext(context.Background())
}

func (i *SecurityGroupRule) ToSecurityGroupRuleOutputWithContext(ctx context.Context) SecurityGroupRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SecurityGroupRuleOutput)
}

type SecurityGroupRuleOutput struct{ *pulumi.OutputState }

func (SecurityGroupRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SecurityGroupRule)(nil)).Elem()
}

func (o SecurityGroupRuleOutput) ToSecurityGroupRuleOutput() SecurityGroupRuleOutput {
	return o
}

func (o SecurityGroupRuleOutput) ToSecurityGroupRuleOutputWithContext(ctx context.Context) SecurityGroupRuleOutput {
	return o
}

func (o SecurityGroupRuleOutput) Action() SecurityGroupRuleActionOutput {
	return o.ApplyT(func(v *SecurityGroupRule) SecurityGroupRuleActionOutput { return v.Action }).(SecurityGroupRuleActionOutput)
}

// The beginning of the range of ports to apply this rule to (inclusive)
func (o SecurityGroupRuleOutput) DestPortFrom() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *SecurityGroupRule) pulumi.Float64PtrOutput { return v.DestPortFrom }).(pulumi.Float64PtrOutput)
}

// The end of the range of ports to apply this rule to (inclusive)
func (o SecurityGroupRuleOutput) DestPortTo() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *SecurityGroupRule) pulumi.Float64PtrOutput { return v.DestPortTo }).(pulumi.Float64PtrOutput)
}

func (o SecurityGroupRuleOutput) Direction() SecurityGroupRuleDirectionOutput {
	return o.ApplyT(func(v *SecurityGroupRule) SecurityGroupRuleDirectionOutput { return v.Direction }).(SecurityGroupRuleDirectionOutput)
}

// Indicates if this rule is editable (will be ignored)
func (o SecurityGroupRuleOutput) Editable() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *SecurityGroupRule) pulumi.BoolPtrOutput { return v.Editable }).(pulumi.BoolPtrOutput)
}

// (IP network)
func (o SecurityGroupRuleOutput) IpRange() pulumi.StringOutput {
	return o.ApplyT(func(v *SecurityGroupRule) pulumi.StringOutput { return v.IpRange }).(pulumi.StringOutput)
}

// The position of this rule in the security group rules list
func (o SecurityGroupRuleOutput) Position() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *SecurityGroupRule) pulumi.Float64PtrOutput { return v.Position }).(pulumi.Float64PtrOutput)
}

func (o SecurityGroupRuleOutput) Protocol() SecurityGroupRuleProtocolOutput {
	return o.ApplyT(func(v *SecurityGroupRule) SecurityGroupRuleProtocolOutput { return v.Protocol }).(SecurityGroupRuleProtocolOutput)
}

func (o SecurityGroupRuleOutput) Rule() ScalewayInstanceV1SecurityGroupRulePtrOutput {
	return o.ApplyT(func(v *SecurityGroupRule) ScalewayInstanceV1SecurityGroupRulePtrOutput { return v.Rule }).(ScalewayInstanceV1SecurityGroupRulePtrOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SecurityGroupRuleInput)(nil)).Elem(), &SecurityGroupRule{})
	pulumi.RegisterOutputType(SecurityGroupRuleOutput{})
}
